# Why do we need repository package?

In any application, we need to **store, retrieve, update, and delete data** from a **database**. This is the essence of **data persistence**.

> **Key Problems Without a Repository:**

* Writing **manual SQL queries** for every data operation is **repetitive and error-prone**.
* Business logic and data access logic can get **tightly coupled**, making the code hard to maintain.
* Managing database connections, transactions, and CRUD operations manually increases **complexity**.

> Principle:Separate data access logic from business logic and automate repetitive database operations to reduce complexity and enhance maintainability.

This is why we use the **repository package and classes**.

## ‚öôÔ∏è **3. How Does the Repository Package and Class Solve This?**

### ‚úÖ **a. What is the Repository Package?**

* The **repository package** is where we place all classes and interfaces that **handle data access** (CRUD operations) in a clean and organized way.
* It **separates data access logic** from business logic, following the **Separation of Concerns (SoC)** principle.

---

### ‚úÖ **b. What is a Repository Class (Interface)?**

* It's an **interface** that extends Spring Data JPA's repository interfaces (like `JpaRepository` or `CrudRepository`).
* It defines **what data operations** are needed but **not how** they are implemented.

## üõ†Ô∏è **4. Example of a Repository Class**

```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email);
}

```

## ‚öôÔ∏è **How Does `findByEmail` Work?**

1. **User-Defined Method**

   * You define the method in your repository interface like this:
   * `findByEmail` is a **user-defined method**, but Spring Data JPA automatically generates the **implementation and SQL** using the **method naming convention**.

```java

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email);
}
```

1. **Spring Data JPA Magic**

   * Spring Boot **analyzes the method name** (`findByEmail`) and:
     * Understands the `findBy` part means a **query**.
     * Identifies `Email` as the **field** in the `User` entity.
     * Automatically generates the SQL query:

```sql
SELECT * FROM users WHERE email = ?;

```

**Where is it Defined?** The method **`findByEmail`** is defined in **your custom interface** (`UserRepository`), but the actual **implementation** is auto-generated by Spring at runtime.

* This behavior is made possible because your interface extends:

```java
public interface UserRepository extends JpaRepository<User, Long>

```

* `JpaRepository` is an interface provided by Spring Data JPA.
* Spring Boot uses **Reflection** and **Proxy Design Pattern** to dynamically create the implementation during runtime.


## üî• **How Does Spring Boot Know Which Field to Use?**

1. The method name **`findByEmail`** matches the **`email` field** in the `User` entity.

```java
@Entity
public class User {
    @Id
    private Long id;
    private String name;
    private String email;
}

```

* Spring uses **reflection** to check if the field `email` exists in the entity.
* Then, it auto-generates the SQL query accordingly.
